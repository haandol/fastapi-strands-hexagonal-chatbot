---
alwaysApply: true
description: Dependency Injection Patterns and Container Management
---

# Dependency Injection

This project uses a custom dependency injection container to manage service dependencies and wiring.

## Core Components

### DI Container
- [DIContainer](mdc:src/di/container.py) - Main dependency injection container
- [container initialization](mdc:src/di/__init__.py) - Container setup and configuration

### Container Lifecycle
- Initialized in [main.py](mdc:src/main.py) as global instance
- Services registered during application startup
- Cleanup performed during application shutdown

## Implementation Patterns

### Container Setup
```python
# Global DI container instance
di_container: DIContainer = DIContainer()

@asynccontextmanager
async def lifespan(_: FastAPI):
    print("ðŸš€ Application started - DI container initialized")
    yield
    # Shutdown
    di_container.cleanup()
    print("ðŸ§¹ Application shutdown - resources cleaned up")
```

### Service Registration
```python
class DIContainer:
    def __init__(self):
        self._services: Dict[Type, Any] = {}
        self._setup_services()

    def _setup_services(self):
        # Register services
        self._services[ChatService] = ChatService(
            self._services[AgentAdapter],
            self._services[SessionAdapter]
        )
```

### Service Resolution
```python
def get_service(self, service_type: Type[T]) -> T:
    if service_type not in self._services:
        raise ValueError(f"Service {service_type} not registered")
    return self._services[service_type]
```

## Best Practices

- Register all services in the container during initialization
- Use constructor injection for all dependencies
- Implement proper cleanup in the container
- Use type hints for service registration and resolution
- Keep services stateless where possible
- Use interfaces (ports) for dependency contracts
- Implement proper error handling for missing services
- Use singleton pattern for shared resources
- Clean up resources during application shutdown
# Dependency Injection

This project uses a custom dependency injection container to manage service dependencies and wiring.

## Core Components

### DI Container
- [DIContainer](mdc:src/di/container.py) - Main dependency injection container
- [container initialization](mdc:src/di/__init__.py) - Container setup and configuration

### Container Lifecycle
- Initialized in [main.py](mdc:src/main.py) as global instance
- Services registered during application startup
- Cleanup performed during application shutdown

## Implementation Patterns

### Container Setup
```python
# Global DI container instance
di_container: DIContainer = DIContainer()

@asynccontextmanager
async def lifespan(_: FastAPI):
    print("ðŸš€ Application started - DI container initialized")
    yield
    # Shutdown
    di_container.cleanup()
    print("ðŸ§¹ Application shutdown - resources cleaned up")
```

### Service Registration
```python
class DIContainer:
    def __init__(self):
        self._services: Dict[Type, Any] = {}
        self._setup_services()

    def _setup_services(self):
        # Register services
        self._services[ChatService] = ChatService(
            self._services[AgentAdapter],
            self._services[SessionAdapter]
        )
```

### Service Resolution
```python
def get_service(self, service_type: Type[T]) -> T:
    if service_type not in self._services:
        raise ValueError(f"Service {service_type} not registered")
    return self._services[service_type]
```

## Best Practices

- Register all services in the container during initialization
- Use constructor injection for all dependencies
- Implement proper cleanup in the container
- Use type hints for service registration and resolution
- Keep services stateless where possible
- Use interfaces (ports) for dependency contracts
- Implement proper error handling for missing services
- Use singleton pattern for shared resources
- Clean up resources during application shutdown
