---
alwaysApply: true
---

# Strands MCP Integration

This project integrates AWS Bedrock through the Strands framework with MCP (Model Context Protocol) support for extensible tool integration.

## Core Components

### MCP Configuration
- [MCPConfig](mdc:src/ports/mcp/config.py) - Configuration models for MCP integration
- [mcp utilities](mdc:src/utils/mcp.py) - MCP client management and utilities

### Strands Integration
- [StrandsMCPAgentAdapter](mdc:src/adapters/secondary/chat/strands_mcp_agent_adapter.py) - Main adapter for Strands with MCP support
- [prompt templates](mdc:src/adapters/secondary/chat/prompt.py) - Prompt engineering for chat interactions

## Key Features

### MCP Support
- Extensible tool integration through Model Context Protocol
- Dynamic tool loading and configuration
- Support for custom MCP servers and tools
- Proper cleanup and resource management

### AWS Bedrock Integration
- Claude model integration through Strands
- Session-based conversation management
- Streaming response support
- Proper error handling and retry logic

### Session Management
- RepositorySessionManager for conversation state
- File-based session persistence
- Session lifecycle management
- Proper cleanup on session termination

## Implementation Patterns

### MCP Configuration
```python
@dataclass
class MCPConfig:
    server_url: str
    tools: List[str]
    model_name: str
    max_tokens: int
```

### Agent Adapter Pattern
```python
class StrandsMCPAgentAdapter(AgentAdapter):
    def __init__(self, config: AppConfig):
        self.config = config
        self.agent: Optional[Agent] = None
        self._setup_signal_handlers()

    async def generate_response_stream(self, session_manager: RepositorySessionManager, content: str) -> AsyncIterator[Any]:
        # Implementation with MCP support
        pass
```

### Resource Management
- Signal handlers for graceful shutdown
- Explicit cleanup methods
- Proper MCP client lifecycle management
- Session cleanup on termination

## Best Practices

- Configure MCP servers through environment variables
- Implement proper error handling for MCP tool failures
- Use structured logging for MCP operations
- Support both streaming and non-streaming responses
- Implement proper resource cleanup
- Handle MCP client connection failures gracefully
- Use session-based conversation context
- Implement proper prompt engineering
- Support multiple MCP tools and servers
- Handle MCP tool responses appropriately
# Strands MCP Integration

This project integrates AWS Bedrock through the Strands framework with MCP (Model Context Protocol) support for extensible tool integration.

## Core Components

### MCP Configuration
- [MCPConfig](mdc:src/ports/mcp/config.py) - Configuration models for MCP integration
- [mcp utilities](mdc:src/utils/mcp.py) - MCP client management and utilities

### Strands Integration
- [StrandsMCPAgentAdapter](mdc:src/adapters/secondary/chat/strands_mcp_agent_adapter.py) - Main adapter for Strands with MCP support
- [prompt templates](mdc:src/adapters/secondary/chat/prompt.py) - Prompt engineering for chat interactions

## Key Features

### MCP Support
- Extensible tool integration through Model Context Protocol
- Dynamic tool loading and configuration
- Support for custom MCP servers and tools
- Proper cleanup and resource management

### AWS Bedrock Integration
- Claude model integration through Strands
- Session-based conversation management
- Streaming response support
- Proper error handling and retry logic

### Session Management
- RepositorySessionManager for conversation state
- File-based session persistence
- Session lifecycle management
- Proper cleanup on session termination

## Implementation Patterns

### MCP Configuration
```python
@dataclass
class MCPConfig:
    server_url: str
    tools: List[str]
    model_name: str
    max_tokens: int
```

### Agent Adapter Pattern
```python
class StrandsMCPAgentAdapter(AgentAdapter):
    def __init__(self, config: AppConfig):
        self.config = config
        self.agent: Optional[Agent] = None
        self._setup_signal_handlers()

    async def generate_response_stream(self, session_manager: RepositorySessionManager, content: str) -> AsyncIterator[Any]:
        # Implementation with MCP support
        pass
```

### Resource Management
- Signal handlers for graceful shutdown
- Explicit cleanup methods
- Proper MCP client lifecycle management
- Session cleanup on termination

## Best Practices

- Configure MCP servers through environment variables
- Implement proper error handling for MCP tool failures
- Use structured logging for MCP operations
- Support both streaming and non-streaming responses
- Implement proper resource cleanup
- Handle MCP client connection failures gracefully
- Use session-based conversation context
- Implement proper prompt engineering
- Support multiple MCP tools and servers
- Handle MCP tool responses appropriately
