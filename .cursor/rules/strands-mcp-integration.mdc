# Strands and MCP Integration Patterns

## Agent Adapter Implementation

The [StrandsMCPAgentAdapter](mdc:src/adapters/secondary/chat/strands_mcp_agent_adapter.py) implements the [AgentAdapter](mdc:src/ports/chat/agent_adapter.py) interface and provides:

### Key Features
- **AWS Bedrock Integration**: Uses Strands framework with Claude models
- **MCP Support**: Model Context Protocol for tool integration
- **Session-based Agents**: Each chat session gets its own agent instance via RepositorySessionManager
- **Streaming Support**: Both streaming and non-streaming response modes
- **Signal-based Resource Management**: Proper cleanup with SIGINT/SIGTERM handling
- **Tool Management**: Dynamic tool and hook registration

### Resource Management & Cleanup
- **Signal Handlers**: Automatic cleanup on SIGINT/SIGTERM signals
- **Explicit Cleanup**: `cleanup()` method for manual resource management
- **Shutdown Method**: Public `shutdown()` method for controlled termination
- **atexit Backup**: Automatic cleanup on program exit
- **MCP Client Lifecycle**: Proper connection/disconnection management

### Interface Contract
The [AgentAdapter](mdc:src/ports/chat/agent_adapter.py) interface requires:
- `generate_response(session_manager: RepositorySessionManager, content: str) -> str`
- `generate_response_stream(session_manager: RepositorySessionManager, content: str) -> AsyncIterator[Any]`
- `configure_mcp(mcp_config: Optional[MCPConfig] = None) -> None`

### MCP Configuration
- [MCPConfig](mdc:src/ports/mcp/config.py) supports both StreamableHttpMCPConfig and StdioMCPConfig
- MCP clients loaded from configuration files via `configure_mcp()`
- Tools automatically registered with agents
- Support for both MCP and local tools

### Best Practices
- Always implement the `AgentAdapter` interface contract
- Use signal handlers for graceful shutdown: `signal.signal(signal.SIGINT, self._signal_handler)`
- Implement explicit cleanup methods: `cleanup()` and `shutdown()`
- Handle MCP client lifecycle properly (connect/disconnect)
- Use structured logging with proper context: `logger.info("message", key=value)`
- Implement proper error handling for AWS/Bedrock operations
- Support both streaming and non-streaming modes
- Use RepositorySessionManager for session management
- Register cleanup handlers in `__init__` with `_setup_cleanup_handlers()`

### Signal Handling Pattern
```python
def _setup_cleanup_handlers(self) -> None:
    signal.signal(signal.SIGINT, self._signal_handler)
    signal.signal(signal.SIGTERM, self._signal_handler)
    atexit.register(self.cleanup)

def _signal_handler(self, signum: int, frame) -> None:
    signal_name = signal.Signals(signum).name
    logger.info(f"ðŸ“¡ received signal {signal_name}, initiating cleanup...")
    self.cleanup()
    signal.signal(signum, signal.SIG_DFL)
    signal.raise_signal(signum)
```

### Environment Configuration
- `MODEL_ID`: AWS Bedrock model identifier
- `AWS_PROFILE_NAME`: AWS credentials profile (optional)
- `MODEL_REGION`: AWS region (optional, defaults to ap-northeast-2)
- `MODEL_TEMPERATURE` and `MODEL_MAX_TOKENS`: Model parameters
description:
globs:
alwaysApply: false
---
