---
alwaysApply: true
---

# Configuration Management

This project uses centralized configuration management with environment-based settings.

## Core Components

### Configuration Models
- [AppConfig](mdc:src/config/app.py) - Main application configuration
- Environment variables loaded via `python-dotenv`
- Type-safe configuration with Pydantic models

### Configuration Sources
- Environment variables (primary)
- `.env` files for local development
- Default values for optional settings

## Implementation Patterns

### Configuration Setup
```python
from dotenv import load_dotenv
load_dotenv()  # Load environment variables

class AppConfig:
    def __init__(self):
        self.model_id = os.getenv("MODEL_ID", "anthropic.claude-3-sonnet-20240229-v1:0")
        self.aws_profile_name = os.getenv("AWS_PROFILE_NAME")
        self.model_region = os.getenv("MODEL_REGION", "ap-northeast-2")
        self.model_temperature = float(os.getenv("MODEL_TEMPERATURE", "0.7"))
        self.model_max_tokens = int(os.getenv("MODEL_MAX_TOKENS", "4096"))
```

### Environment Variables
- `MODEL_ID` - AWS Bedrock model identifier
- `AWS_PROFILE_NAME` - AWS credentials profile (optional)
- `MODEL_REGION` - AWS region (defaults to ap-northeast-2)
- `MODEL_TEMPERATURE` - Model temperature parameter
- `MODEL_MAX_TOKENS` - Maximum tokens for responses
- `PORT` - Application port (defaults to 8000)

## Best Practices

- Use environment variables for all configuration
- Provide sensible defaults for optional settings
- Use type-safe configuration models
- Load configuration early in application startup
- Use `.env` files for local development
- Keep sensitive information in environment variables
- Use structured configuration objects
- Validate configuration values
- Support different environments (dev, staging, prod)
- Use configuration for feature flags
# Configuration Management

This project uses centralized configuration management with environment-based settings.

## Core Components

### Configuration Models
- [AppConfig](mdc:src/config/app.py) - Main application configuration
- Environment variables loaded via `python-dotenv`
- Type-safe configuration with Pydantic models

### Configuration Sources
- Environment variables (primary)
- `.env` files for local development
- Default values for optional settings

## Implementation Patterns

### Configuration Setup
```python
from dotenv import load_dotenv
load_dotenv()  # Load environment variables

class AppConfig:
    def __init__(self):
        self.model_id = os.getenv("MODEL_ID", "anthropic.claude-3-sonnet-20240229-v1:0")
        self.aws_profile_name = os.getenv("AWS_PROFILE_NAME")
        self.model_region = os.getenv("MODEL_REGION", "ap-northeast-2")
        self.model_temperature = float(os.getenv("MODEL_TEMPERATURE", "0.7"))
        self.model_max_tokens = int(os.getenv("MODEL_MAX_TOKENS", "4096"))
```

### Environment Variables
- `MODEL_ID` - AWS Bedrock model identifier
- `AWS_PROFILE_NAME` - AWS credentials profile (optional)
- `MODEL_REGION` - AWS region (defaults to ap-northeast-2)
- `MODEL_TEMPERATURE` - Model temperature parameter
- `MODEL_MAX_TOKENS` - Maximum tokens for responses
- `PORT` - Application port (defaults to 8000)

## Best Practices

- Use environment variables for all configuration
- Provide sensible defaults for optional settings
- Use type-safe configuration models
- Load configuration early in application startup
- Use `.env` files for local development
- Keep sensitive information in environment variables
- Use structured configuration objects
- Validate configuration values
- Support different environments (dev, staging, prod)
- Use configuration for feature flags
